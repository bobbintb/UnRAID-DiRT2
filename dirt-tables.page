Menu="DiskUtilities"
Title="Deduplication in Real-Time"
Icon="fa-search-minus"
---
<link href="https://unpkg.com/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet">
<link href="/plugins/bobbintb.system.dirt/nodejs/frontend/css/dirt-tabulator.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/frontend/dirt-tabulator-formatters.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/frontend/dirt-tabulator-helpers.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/frontend/left-table.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/frontend/right-table.js"></script>
<script src="https://unpkg.com/split.js/dist/split.min.js"></script>

<div class="table-container">
    <div id="left-table" class="table-wrapper"></div>
    <div id="right-panel">
        <div id="right-table" class="table-wrapper"></div>
        <button id="process-button">Process</button>
    </div>
</div>

<script>
    let socket;
    function dirtySock(action, data) {
        const message = {
            clientId: "dirt-tables.page",
            action: action,
            data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(message));
        } else {
            console.error("Tabulator Tab: WebSocket is not connected.");
        }
    }

document.addEventListener('DOMContentLoaded', function() {
    Split(['#left-table', '#right-panel'], {
        sizes: [70, 30],
        gutterSize: 8,
        cursor: 'col-resize'
    });

    const leftTable = new Tabulator("#left-table", generateLeftTableConfig(dirtySock));
    const rightTable = new Tabulator("#right-table", rightTableConfig);

    rightTable.on("tableBuilt", function(){
        rightTable.setFilter(function(data){
            return data.action === "link" || data.action === "delete";
        });
    });

    rightTable.on("dataChanged", () => {
        rightTable.refreshFilter();
    });

    function connect() {
        socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tables.page`);

        socket.onopen = function() {
            console.log("Tabulator Tab: WebSocket connection established.");
            dirtySock('findDuplicates', null);
        };

        socket.onmessage = function(event) {
            const parsedMessage = JSON.parse(event.data);
            const { action, data } = parsedMessage;

            if (action === 'duplicateFiles') {
                console.log("Tabulator Tab: Received duplicateFiles data package.");
                const { duplicates, state, actions } = data;
                const { leftTableData, rightTableData } = processDuplicateFiles(duplicates, state, actions);
                rightTable.setData(rightTableData);
                leftTable.setData(leftTableData);
            } else if (action === 'addOrUpdateFile') {
                console.log(`Tabulator Tab: Received addOrUpdateFile for ino ${data.ino}`);
                const paths = data.path.split('<br>');

                // Remove stale rows (paths that are no longer in the file's path list)
                const existingRows = rightTable.getRows().filter(r => r.getData().ino == data.ino);
                existingRows.forEach(r => {
                     const p = r.getData().path;
                     if (!paths.includes(p)) {
                         r.delete();
                     }
                });

                // Also handle stale rows in subtable if visible
                const subTable = findSubTableByHash(data.hash);
                if (subTable) {
                    const existingSubRows = subTable.getRows().filter(r => r.getData().ino == data.ino);
                    existingSubRows.forEach(r => {
                         const p = r.getData().path;
                         if (!paths.includes(p)) {
                             r.delete();
                         }
                    });
                }

                const newRows = paths.map(p => {
                    const existingRow = rightTable.getRow(p);
                    let existingData = {};
                    if (existingRow) {
                        existingData = existingRow.getData();
                    }
                    return {
                        ...data,
                        path: p,
                        action: existingData.action || null,
                        isOriginal: existingData.isOriginal || false
                    };
                });

                rightTable.updateOrAddData(newRows);
                if (subTable) {
                    subTable.updateOrAddData(newRows);
                }
            } else if (action === 'removeFile') {
                console.log(`Tabulator Tab: Received removeFile for ino ${data.ino}`);
                // 1. Update Right Table
                const rightRows = rightTable.getRows().filter(r => r.getData().ino == data.ino);
                rightRows.forEach(r => r.delete());

                // 2. Update Left Table (find parent row)
                leftTable.getRows().forEach(row => {
                    const rowData = row.getData();
                    if (rowData.fileList && rowData.fileList.some(f => f.ino == data.ino)) {
                        const rowEl = row.getElement();
                        const subTableEl = rowEl.querySelector(".tabulator-table");
                        if (subTableEl) {
                             const tables = Tabulator.findTable(subTableEl);
                             if (tables && tables.length > 0) {
                                 const subTable = tables[0];
                                 const subRows = subTable.getRows().filter(r => r.getData().ino == data.ino);
                                 subRows.forEach(r => r.delete());
                             }
                        }
                    }
                });
            }

        };

        function findSubTableByHash(hash) {
            const row = leftTable.getRow(hash);
            if (row) {
                const rowEl = row.getElement();
                const subTableEl = rowEl.querySelector(".tabulator-table");
                if (subTableEl) {
                    const table = Tabulator.findTable(subTableEl);
                    return table ? table[0] : null;
                }
            }
            return null;
        }

        socket.onclose = function(event) {
            console.log("Tabulator Tab: WebSocket connection closed. Reconnecting...");
            setTimeout(connect, 1000);
        };

        socket.onerror = function(error) {
            console.error("Tabulator Tab: WebSocket error: ", error);
            socket.close();
        };
    }

    function dirtySock(action, data) {
        const message = {
            clientId: "dirt-tables.page",
            action: action,
            data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(message));
        } else {
            console.error("Tabulator Tab: WebSocket is not connected.");
        }
    }

    document.getElementById('process-button').addEventListener('click', () => {
        const tableData = rightTable.getData("active");
        let message = "Actions to be performed:\n\n";
        tableData.forEach(row => {
            message += `Action: ${row.action}, Path: ${row.path}\n`;
        });
        alert(message);
    });

    connect();
});
</script>
