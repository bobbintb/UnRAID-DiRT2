Menu="DiskUtilities"
Title="Deduplication in Real-Time"
Icon="fa-search-minus"
---
<link href="https://unpkg.com/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet">
<link href="/plugins/bobbintb.system.dirt/nodejs/css/dirt-tabulator.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
<script src="https://unpkg.com/split.js/dist/split.min.js"></script>
<div id="split">
    <div id="duplicatesTable-container">
        <div id="duplicatesTable"></div>
    </div>
    <div id="action-queue-container">
        <div id="action-queue-table"></div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    Split(['#duplicatesTable-container', '#action-queue-container'], {
        gutterSize: 10,
        sizes: [70, 30], // Initial sizes in percentage
        minSize: [200, 100], // Minimum sizes in pixels
    });

    let socket;
    let table;
    let actionQueueTable;
    let actionQueueData = {}; // To hold the initial queue state

    // The Tabulator table definition for the Action Queue
    actionQueueTable = new Tabulator("#action-queue-table", {
        height: "100%",
        data: [],
        placeholder: "No actions queued",
        layout: "fitColumns",
        columns: [
            {
                title: `<i class="fa fa-trash" style="cursor: pointer;" title="Remove All"></i>`,
                field: "action",
                hozAlign: "center",
                width: 40,
                minWidth: 40,
                resizable: false,
                headerSort: false,
                headerHozAlign: "center",
                headerClick: function(e, column) {
                    const rows = actionQueueTable.getRows();
                    rows.forEach(row => {
                        const cell = row.getCell('action');
                        const icon = cell.getElement().querySelector('i');
                        if (icon) {
                            icon.click();
                        }
                    });
                },
                formatter: function(cell, formatterParams, onRendered) {
                    const action = cell.getValue();
                    const iconClass = action === 'delete' ? 'fa-trash' : 'fa-link';
                    return `<i class="fa ${iconClass}" style="cursor: pointer;" title="Remove"></i>`;
                },
                cellClick: function(e, cell) {
                    const rowData = cell.getRow().getData();
                    const filePath = rowData.file;

                    // 1. Remove the action from the queue (UI and backend)
                    removeFileActionFromQueue(filePath);

                    // 2. Find the corresponding row in the main table and uncheck its radio
                    const matchingRows = table.searchRows("path", "=", filePath);
                    if (matchingRows.length > 0) {
                        const actionCell = matchingRows[0].getCell('action');
                        const radioInputs = actionCell.getElement().querySelectorAll('input[type="radio"]');
                        radioInputs.forEach(radio => {
                            if (radio.checked) {
                                radio.click(); // Simulate a click to uncheck and trigger logic
                            }
                        });
                    }
                }
            },
            { title: "File", field: "file", hozAlign: "left", tooltip: true },
        ],
    });

    // Helper function to remove an action from the queue (UI and backend)
    function removeFileActionFromQueue(filePath) {
        // 1. Send message to backend to remove from Redis
        dirtySock('removeFileAction', { path: filePath });

        // 2. Remove the row from the action queue table
        actionQueueTable.getRows().forEach(row => {
            if (row.getData().file === filePath) {
                row.delete();
            }
        });
    }

    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    // Helper function to format dates
    function formatDate(cell) {
        const value = cell.getValue();
        return value ? new Date(value).toLocaleString() : '';
    }

    // Helper function to format size
    function formatSize(cell) {
        const value = cell.getValue();
        return formatBytes(value);
    }

    // The Tabulator table definition
    table = new Tabulator("#duplicatesTable", {
        height: "100%", // Use full page height
        data: [], // Set initial data to empty
        placeholder: "No duplicate files found",
        layout: "fitColumns",
        groupBy: "hash",
        groupHeader: function(value, count, data, group) {
            // Calculate total size
            const totalSize = data.reduce((acc, row) => acc + (row.size || 0), 0);
            const groupHash = value;
            const uniqueName = "action_group_" + groupHash;

            // Create a container div to hold the HTML and attach events
            const container = document.createElement('div');
            container.className = 'group-header-flex-container';

            // Use an HTML string for simplicity and readability
            container.innerHTML = `
                <div class="group-action-container">
                    <input type="radio" name="${uniqueName}" value="delete" id="del_${uniqueName}" data-nullable="true">
                    <label for="del_${uniqueName}" title="Delete All"><i class="fa fa-trash"></i></label>
                    <input type="radio" name="${uniqueName}" value="link" id="link_${uniqueName}" data-nullable="true">
                    <label for="link_${uniqueName}" title="Hardlink All"><i class="fa fa-link"></i></label>
                </div>
                <div class="group-info-container">
                    <strong>Group: ${value}</strong>
                    <span>(${count} files, ${formatBytes(totalSize)})</span>
                </div>
            `;

            // Find the radio buttons within the newly created HTML
            const delRadio = container.querySelector(`#del_${uniqueName}`);
            const linkRadio = container.querySelector(`#link_${uniqueName}`);

            // Event Handling for Group Header Actions
            const groupActionChangeHandler = function(e) {
                e.stopPropagation(); // Prevent group from collapsing/expanding
                const target = e.target;
                const action = target.value;

                // Handle nullable radio logic
                if (target.checked && target.getAttribute('data-waschecked') === 'true') {
                    target.checked = false;
                    target.setAttribute('data-waschecked', 'false');
                } else {
                    // Unset waschecked on both before setting it on the target
                    delRadio.setAttribute('data-waschecked', 'false');
                    linkRadio.setAttribute('data-waschecked', 'false');
                    target.setAttribute('data-waschecked', 'true');
                }

                const effectiveCheckedState = target.checked;
                const childRows = group.getRows();

                // Apply the action to all non-disabled child rows
                childRows.forEach(row => {
                    if (row.getElement().classList.contains('disabled-row')) {
                        return; // Skip disabled rows
                    }
                    const actionCell = row.getCell('action').getElement();
                    const childRadio = actionCell.querySelector(`input[value="${action}"]`);
                    if (childRadio) {
                        // Click the child radio only if its state is different from the header's state
                        if ((effectiveCheckedState && !childRadio.checked) || (!effectiveCheckedState && childRadio.checked)) {
                            childRadio.click();
                        }
                    }
                });
            };

            delRadio.addEventListener('click', groupActionChangeHandler);
            linkRadio.addEventListener('click', groupActionChangeHandler);

            return container;
        },
        rowFormatter: function(row) {
            const data = row.getData();
            if (data.isOriginal) {
                row.getElement().classList.add('disabled-row');
            }
        },
        columns: [
            {
                title: "",
                field: "isPrimary",
                hozAlign: "center",
                headerSort: false,
                width: 30,
                minWidth: 30,
                resizable: false,
                formatter: function(cell, formatterParams, onRendered) {
                    const data = cell.getRow().getData();
                    const radio = document.createElement("input");
                    radio.type = "radio";
                    radio.name = "primary_group_" + data.hash;
                    radio.checked = data.isOriginal;

                    radio.addEventListener('click', function() {
                        const clickedRow = cell.getRow();
                        const groupRows = clickedRow.getGroup().getRows();

                        groupRows.forEach(row => {
                            const rowEl = row.getElement();
                            if (row.getData().ino === clickedRow.getData().ino) {
                                rowEl.classList.add('disabled-row');
                                // Uncheck any action radios in this row and remove from queue
                                const actionRadios = rowEl.querySelectorAll('.tabulator-cell[tabulator-field="action"] input[type="radio"]');
                                actionRadios.forEach(r => r.checked = false);
                                removeFileActionFromQueue(clickedRow.getData().path);
                            } else {
                                rowEl.classList.remove('disabled-row');
                            }
                        });

                        // Send the selection to the backend
                        const groupHash = clickedRow.getData().hash;
                        const fileIno = clickedRow.getData().ino;
                        dirtySock('setOriginalFile', { hash: groupHash, ino: fileIno });
                    });

                    return radio;
                }
            },
            {
                field: "action",
                hozAlign: "center",
                headerSort: false,
                width: 65,
                resizable: false,
                titleFormatter: function(cell, formatterParams, onRendered){
                    const uniqueName = "action_group_table_header";

                    // Create a container div, mirroring the groupHeader structure for correct styling and functionality
                    const container = document.createElement('div');
                    container.className = 'group-header-flex-container';
                    container.style.justifyContent = 'center';

                    container.innerHTML = `
                        <div class="group-action-container">
                            <input type="radio" name="${uniqueName}" value="delete" id="del_${uniqueName}" data-nullable="true">
                            <label for="del_${uniqueName}" title="Delete All"><i class="fa fa-trash"></i></label>
                            <input type="radio" name="${uniqueName}" value="link" id="link_${uniqueName}" data-nullable="true">
                            <label for="link_${uniqueName}" title="Hardlink All"><i class="fa fa-link"></i></label>
                        </div>
                    `;

                    // Find the radio buttons within the newly created HTML
                    const delRadio = container.querySelector(`#del_${uniqueName}`);
                    const linkRadio = container.querySelector(`#link_${uniqueName}`);

                    // Event Handling - this logic is adapted directly from the working groupHeader handler
                    const headerActionClickHandler = function(e) {
                        const target = e.target;
                        const action = target.value;

                        // Handle nullable radio logic
                        if (target.checked && target.getAttribute('data-waschecked') === 'true') {
                            target.checked = false;
                            target.setAttribute('data-waschecked', 'false');
                        } else {
                            delRadio.setAttribute('data-waschecked', 'false');
                            linkRadio.setAttribute('data-waschecked', 'false');
                            target.setAttribute('data-waschecked', 'true');
                        }

                        const effectiveCheckedState = target.checked;
                        const groups = table.getGroups();

                        // Cascade the click to the group headers
                        groups.forEach(group => {
                            const groupEl = group.getElement();
                            const groupRadio = groupEl.querySelector(`input[value="${action}"]`);
                            if (groupRadio) {
                                if ((effectiveCheckedState && !groupRadio.checked) || (!effectiveCheckedState && groupRadio.checked)) {
                                    groupRadio.click();
                                }
                            }
                        });
                    };

                    delRadio.addEventListener('click', headerActionClickHandler);
                    linkRadio.addEventListener('click', headerActionClickHandler);

                    return container;
                },
                formatter: function(cell, formatterParams, onRendered) {
                    const data = cell.getRow().getData();
                    const uniqueName = "action_" + data.ino;
                    const container = document.createElement("div");

                    // --- Delete Radio ---
                    const delRadio = document.createElement("input");
                    delRadio.type = "radio";
                    delRadio.name = uniqueName;
                    delRadio.value = "delete";
                    delRadio.id = `del_${uniqueName}`;
                    delRadio.dataset.nullable = true;
                    if (actionQueueData[data.path] === 'delete') {
                        delRadio.checked = true;
                        delRadio.setAttribute('data-waschecked', 'true');
                    }

                    const delLabel = document.createElement("label");
                    delLabel.htmlFor = `del_${uniqueName}`;
                    delLabel.title = "Delete";
                    delLabel.innerHTML = `<i class="fa fa-trash"></i>`;

                    // --- Link Radio ---
                    const linkRadio = document.createElement("input");
                    linkRadio.type = "radio";
                    linkRadio.name = uniqueName;
                    linkRadio.value = "link";
                    linkRadio.id = `link_${uniqueName}`;
                    linkRadio.dataset.nullable = true;
                    if (actionQueueData[data.path] === 'link') {
                        linkRadio.checked = true;
                        linkRadio.setAttribute('data-waschecked', 'true');
                    }

                    const linkLabel = document.createElement("label");
                    linkLabel.htmlFor = `link_${uniqueName}`;
                    linkLabel.title = "Hardlink";
                    linkLabel.innerHTML = `<i class="fa fa-link"></i>`;

                    // --- Event Handling for Nullable ---
                        const actionChangeHandler = function(e) {
                        const target = e.target;
                            const filePath = cell.getRow().getData().path;

                            // Handle nullable logic
                        if (target.checked && target.getAttribute('data-waschecked') === 'true') {
                            target.checked = false;
                            target.setAttribute('data-waschecked', 'false');
                            // Remove from queue and table
                            removeFileActionFromQueue(filePath);
                        } else {
                                // Set waschecked for all radios in this cell
                            delRadio.setAttribute('data-waschecked', 'false');
                            linkRadio.setAttribute('data-waschecked', 'false');
                            target.setAttribute('data-waschecked', 'true');
                                // Add/update in queue and table
                                dirtySock('setFileAction', { path: filePath, action: target.value });
                                // Remove existing entry if it exists, then add the new one
                                actionQueueTable.getRows().forEach(row => {
                                    if (row.getData().file === filePath) {
                                        row.delete();
                                    }
                                });
                                actionQueueTable.addRow({ action: target.value, file: filePath });
                        }
                    };

                        delRadio.addEventListener('click', actionChangeHandler);
                        linkRadio.addEventListener('click', actionChangeHandler);

                    container.appendChild(delRadio);
                    container.appendChild(delLabel);
                    container.appendChild(linkRadio);
                    container.appendChild(linkLabel);

                    return container;
                }
            },
            {
                title: "File",
                field: "path",
                headerSort: false,
                widthGrow: 1,
                bottomCalc: "count",
            },
            { title: "Size", field: "size", formatter: formatSize, width: 90, resizable: false },
            { title: "Modified", field: "mtime", formatter: formatDate, width: 170, resizable: false },
            { title: "Changed", field: "ctime", formatter: formatDate, width: 170, resizable: false }
        ],
    });

    function connect() {
        socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tabulator.page`);

        socket.onopen = function() {
            console.log("Tabulator Tab: WebSocket connection established.");
            // Request the consolidated data payload
            dirtySock('findDuplicates', null);
        };

        socket.onmessage = function(event) {
            const parsedMessage = JSON.parse(event.data);
            const { action, data } = parsedMessage;

            if (action === 'duplicateFiles') {
                console.log("Tabulator Tab: Received duplicateFiles data package.");
                const { duplicates, state, queue } = data;
                processAndRenderTable(duplicates, state, queue);
            }
        };

        function processAndRenderTable(duplicateFilesData, originalFileState, receivedActionQueueData) {
            console.log("Tabulator Tab: Processing and rendering tables.");

            // Store the queue data for use in formatters
            actionQueueData = receivedActionQueueData;

            // 1. Populate the Action Queue table
            const queueTableData = Object.entries(actionQueueData).map(([path, action]) => ({
                action: action,
                file: path,
            }));
            actionQueueTable.setData(queueTableData);


            // 2. Populate the main duplicates table with a flat list of files
            const tableData = [];
            duplicateFilesData.forEach(group => {
                const originalIno = originalFileState[group.hash];
                group.files.forEach((file, index) => {
                    const isOriginal = originalIno ? (file.ino === originalIno) : (index === 0);
                    tableData.push({
                        ...file,
                        hash: group.hash, // Add hash to each file for grouping
                        isOriginal: isOriginal
                    });
                });
            });

            table.setData(tableData);
        }

        socket.onclose = function(event) {
            console.log("Tabulator Tab: WebSocket connection closed. Reconnecting...");
            setTimeout(connect, 1000);
        };

        socket.onerror = function(error) {
            console.error("Tabulator Tab: WebSocket error: ", error);
            socket.close();
        };
    }

    function dirtySock(action, data) {
        const message = {
            clientId: "dirt-tabulator.page",
            action: action,
            data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(message));
        } else {
            console.error("Tabulator Tab: WebSocket is not connected.");
        }
    }

    connect();
});
</script>
