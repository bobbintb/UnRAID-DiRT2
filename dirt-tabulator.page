Menu="DiskUtilities"
Title="Deduplication in Real-Time"
Icon="fa-search-minus"
---
<link href="https://unpkg.com/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet">
<link href="/plugins/bobbintb.system.dirt/nodejs/css/dirt-tabulator.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
<script src="https://unpkg.com/split.js/dist/split.min.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/dirt-tabulator-helpers.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/dirt-tabulator-formatters.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/dirt-tabulator-actions.js"></script>
<div id="split">
    <div id="duplicatesTable-container">
        <div id="duplicatesTable"></div>
    </div>
    <div id="action-queue-container">
        <div id="action-queue-table"></div>
        <div id="action-queue-footer" style="display: flex; justify-content: space-between; align-items: center; padding: 5px; border-top: 1px solid #ccc;">
            <div id="action-queue-summary">
                <span>Items: 0</span> | <span>Total Size: 0 Bytes</span>
            </div>
            <div>
                <button id="reset-button">Reset</button>
                <button id="process-button">Process</button>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    Split(['#duplicatesTable-container', '#action-queue-container'], {
        gutterSize: 10,
        sizes: [70, 30], // Initial sizes in percentage
        minSize: [200, 100], // Minimum sizes in pixels
    });

    let socket;
    let table;
    let actionQueueTable;
    let actionQueueData = {}; // To hold the initial queue state
    let tableData = []; // This will be our reactive data array

    actionQueueTable = new Tabulator("#action-queue-table", {
        height: "100%",
        reactiveData: true,
        data: tableData, // Point to the main reactive data array
        placeholder: "No actions queued",
        layout: "fitColumns",
        initialFilter: [
            { field: "queuedAction", type: "!=", value: null }
        ],
        columns: [
            {
                title: `<i class="fa fa-trash" style="cursor: pointer;" title="Remove All"></i>`,
                hozAlign: "center",
                width: 40,
                minWidth: 40,
                resizable: false,
                headerSort: false,
                headerHozAlign: "center",
                headerClick: function(e, column) {
                    handleClearQueueClick(tableData, dirtySock, table);
                },
                formatter: createActionQueueActionFormatter(),
                cellClick: function(e, cell) {
                    handleActionQueueRowClick(cell, dirtySock, actionQueueTable);
                }
            },
            { title: "Action", field: "queuedAction", width: 80, hozAlign: "center" },
            { title: "File", field: "path", hozAlign: "left", tooltip: true },
        ],
    });

    function getDuplicatesTableColumnDefinitions(dirtySock, actionQueueTable) {
        return [
            {
                title: "",
                field: "isOriginal", // The field is now boolean `isOriginal`
                hozAlign: "center",
                headerSort: false,
                width: 30,
                minWidth: 30,
                resizable: false,
                formatter: createIsPrimaryFormatter(dirtySock, actionQueueTable),
                // Event handling is now in the formatter, calling the centralized action handler
            },
            {
                field: "queuedAction", // The field is now the string `queuedAction`
                hozAlign: "center",
                headerSort: false,
                width: 65,
                resizable: false,
                titleFormatter: createActionTitleFormatter(),
                headerClick: function(e, column) {
                    if (e.target.tagName === 'INPUT') {
                        handleHeaderActionClick(e, table, dirtySock, actionQueueTable);
                    }
                },
                formatter: createActionFormatter(dirtySock, actionQueueTable),
                // Event handling is now in the formatter, calling the centralized action handler
            },
            {
                title: "File",
                field: "path",
                headerSort: false,
                widthGrow: 1,
                bottomCalc: "count",
            },
            { title: "Size", field: "size", formatter: formatSize, width: 90, resizable: false },
            { title: "Modified", field: "mtime", formatter: formatDate, width: 170, resizable: false },
            { title: "Changed", field: "ctime", formatter: formatDate, width: 170, resizable: false }
        ]
    }

    function getDuplicatesTableConfig(dirtySock, actionQueueTable) {
        return {
            height: "100%",
            reactiveData: true,
            data: tableData,
            placeholder: "No duplicate files found",
            layout: "fitColumns",
            groupBy: "hash",
            groupHeader: createGroupHeader(dirtySock, actionQueueTable),
            rowFormatter: createRowFormatter(),
            columns: getDuplicatesTableColumnDefinitions(dirtySock, actionQueueTable),
        };
    }

    // The Tabulator table definition
    table = new Tabulator("#duplicatesTable", getDuplicatesTableConfig(dirtySock, actionQueueTable));

    function connect() {
        socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tabulator.page`);

        socket.onopen = function() {
            console.log("Tabulator Tab: WebSocket connection established.");
            dirtySock('findDuplicates', null);
        };

        socket.onmessage = function(event) {
            const parsedMessage = JSON.parse(event.data);
            const { action, data } = parsedMessage;

            if (action === 'duplicateFiles') {
                console.log("Tabulator Tab: Received duplicateFiles data package.");
                const { duplicates, state, queue } = data;
                processAndRenderTable(duplicates, state, queue);
            } else if (action === 'resetComplete') {
                console.log("Tabulator Tab: Received resetComplete confirmation. Fetching fresh data.");
                dirtySock('findDuplicates', null);
            }
        };

        function updateQueueFooter() {
            const rows = actionQueueTable.getRows('active'); // Get active (filtered) rows
            const itemCount = rows.length;
            const totalSize = rows.reduce((acc, row) => acc + row.getData().size, 0);
            const summaryEl = document.getElementById('action-queue-summary');
            summaryEl.innerHTML = `<span>Items: ${itemCount}</span> | <span>Total Size: ${formatBytes(totalSize)}</span>`;
        }

        function processAndRenderTable(duplicateFilesData, originalFileState, receivedActionQueueData) {
            console.log("Tabulator Tab: Processing and rendering tables.");
            actionQueueData = receivedActionQueueData; // Keep for legacy formatters for now

            // Clear out the old data by replacing the array contents
            tableData.length = 0;

            duplicateFilesData.forEach(group => {
                const originalIno = originalFileState[group.hash];
                group.files.forEach((file, index) => {
                    const isOriginal = originalIno ? (file.ino === originalIno) : (index === 0);
                    const queuedAction = receivedActionQueueData[file.path] || null;
                    tableData.push({
                        ...file,
                        hash: group.hash,
                        isOriginal: isOriginal,
                        queuedAction: queuedAction,
                    });
                });
            });

            // Both tables are reactive and point to the same data.
            // We must explicitly tell both to replace the data to ensure they
            // re-render and re-apply filters correctly.
            Promise.all([
                table.replaceData(tableData),
                actionQueueTable.replaceData(tableData)
            ]).then(() => {
                updateQueueFooter();
            });
        }

        socket.onclose = function(event) {
            console.log("Tabulator Tab: WebSocket connection closed. Reconnecting...");
            setTimeout(connect, 1000);
        };

        socket.onerror = function(error) {
            console.error("Tabulator Tab: WebSocket error: ", error);
            socket.close();
        };
    }

    function dirtySock(action, data) {
        const message = {
            clientId: "dirt-tabulator.page",
            action: action,
            data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(message));
        } else {
            console.error("Tabulator Tab: WebSocket is not connected.");
        }
    }

    connect();

    document.getElementById('reset-button').addEventListener('click', function() {
        if (confirm("Are you sure you want to reset all actions and original file selections?")) {
            // Send message to backend to clear the state. The `resetComplete`
            // message handler will then trigger the data refresh.
            dirtySock('resetState', {});
        }
    });

    document.getElementById('process-button').addEventListener('click', function() {
        const rows = actionQueueTable.getRows();
        if (rows.length === 0) {
            alert("The action queue is empty.");
            return;
        }

        let confirmationMessage = "Are you sure you want to perform the following actions?\n\n";
        rows.forEach(row => {
            const data = row.getData();
            const action = data.action.charAt(0).toUpperCase() + data.action.slice(1); // Capitalize
            confirmationMessage += `${action}: ${data.file}\n`;
        });

        confirm(confirmationMessage);
    });
});
</script>
