Menu="dirtSettings:4"
Title="Tabulator"
---
<link href="https://unpkg.com/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>

<div id="duplicatesTable-tabulator"></div>

<script>
document.addEventListener("DOMContentLoaded", function() {
    let socket;
    let table;

    function connect() {
      socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tabulator.page`);

      socket.onopen = function() {
        console.log("Tabulator Tab: WebSocket connection established.");
        dirtySock('findDuplicates', null);
      };

      socket.onmessage = function(event) {
        const parsedMessage = JSON.parse(event.data);
        const { action, data } = parsedMessage;

        if (action === 'duplicateFiles') {
          console.log("Tabulator Tab: Received duplicateFiles data.");

          // Add a unique ID and expanded state for each parent row
          const tableData = data.map((group, index) => {
              return { ...group, id: index, _expanded: false };
          });

          table = new Tabulator("#duplicatesTable-tabulator", {
              data: tableData,
              layout: "fitColumns",
              placeholder: "No duplicate files found",
              rowFormatter: function(row){
                // Apply styling to child rows
                if(row.getData()._isChild){
                    row.getElement().style.backgroundColor = "#f5f5f5";
                }
              },
              columns: [
                  {
                      title: "",
                      width: 40,
                      hozAlign: "center",
                      formatter: (cell) => {
                          const rowData = cell.getRow().getData();
                          // Only show the icon on parent rows
                          if (rowData.hash) {
                              return rowData._expanded ? "-" : "+";
                          }
                          return "";
                      },
                      cellClick: (e, cell) => {
                          const row = cell.getRow();
                          const rowData = row.getData();

                          if (!rowData.hash) return; // Not a parent row

                          rowData._expanded = !rowData._expanded;
                          row.update({ _expanded: rowData._expanded }); // Update the row data

                          if (rowData._expanded) {
                              // Expand: Add child rows
                              const childRows = rowData.files.map(file => {
                                  return { ...file, _isChild: true, _parentId: rowData.id };
                              });
                              table.addRows(childRows, false, row);
                          } else {
                              // Collapse: Remove child rows
                              const children = table.getRows().filter(r => r.getData()._parentId === rowData.id);
                              children.forEach(child => child.delete());
                          }
                      }
                  },
                  { title: "Hash", field: "hash" },
                  { title: "File Count", field: "files", formatter: (cell) => cell.getValue() ? cell.getValue().length : '' },
                  { title: "Size", field: "size" },
                  { title: "Path", field: "path", visible: false }, // Hide, but keep for data access
                  { title: "Modified", field: "mtime", visible: false } // Hide, but keep for data access
              ],
          });

          // After the table is built, we redefine the columns for the child rows
          // This is a bit of a workaround to get the desired layout.
          // We can't have different column defs for parent/child directly.
          // Instead, we will format the parent row cells to show the child data.
          // No, the manual addRows/deleteRows is the cleaner way. The above logic is correct.
          // The child rows will just display their data in the same columns.
          // Let's adjust the columns to show child data if it exists.

          table.setColumns([
               {
                      title: "",
                      width: 40,
                      hozAlign: "center",
                      formatter: (cell) => {
                          const rowData = cell.getRow().getData();
                          if (rowData.hash) {
                              return rowData._expanded ? "-" : "+";
                          }
                          return "";
                      },
                      cellClick: (e, cell) => {
                          const row = cell.getRow();
                          const rowData = row.getData();
                          if (!rowData.hash) return;
                          rowData._expanded = !rowData._expanded;
                          row.update({ _expanded: rowData._expanded });
                          if (rowData._expanded) {
                              const childRows = rowData.files.map(file => ({ ...file, _isChild: true, _parentId: rowData.id }));
                              // The correct method is addRow, which must be called for each row.
                              childRows.forEach(child => table.addRow(child, false, row));
                          } else {
                              const children = table.getRows().filter(r => r.getData()._parentId === rowData.id);
                              children.forEach(child => child.delete());
                          }
                      }
                  },
                  {
                      title: "Hash / Path",
                      field: "hash",
                      widthGrow: 3,
                      formatter: (cell) => {
                          const data = cell.getRow().getData();
                          return data._isChild ? data.path : `<strong>${data.hash}</strong>`;
                      },
                      htmlOutput: true
                  },
                  {
                      title: "Count / Modified",
                      widthGrow: 1.5,
                      formatter: (cell) => {
                          const data = cell.getRow().getData();
                          if (data._isChild) {
                              return data.mtime ? new Date(data.mtime).toLocaleString() : '';
                          }
                          return data.files ? data.files.length : '';
                      }
                  },
                  {
                      title: "Size",
                      field: "size",
                      widthGrow: 1,
                      formatter: (cell) => {
                          const data = cell.getRow().getData();
                          return data._isChild ? '' : data.size;
                      }
                  }
          ]);
        }
      };

      socket.onclose = function(event) {
        console.log("Tabulator Tab: WebSocket connection closed. Reconnecting...");
        setTimeout(connect, 1000);
      };

      socket.onerror = function(error) {
        console.error("Tabulator Tab: WebSocket error: ", error);
        socket.close();
      };
    }

    function dirtySock(action, data) {
        const message = {
          clientId: "dirt-tabulator.page",
          action: action,
          data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify(message));
        } else {
          console.error("Tabulator Tab: WebSocket is not connected.");
        }
    }

    connect();
});
</script>
