Menu="DiskUtilities"
Title="Deduplication in Real-Time"
Icon="fa-search-minus"
---
<link href="https://unpkg.com/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet">
<link href="/plugins/bobbintb.system.dirt/nodejs/css/dirt-tabulator.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
<script src="https://unpkg.com/split.js/dist/split.min.js"></script>
<div id="split">
    <div id="duplicatesTable-container">
        <div id="duplicatesTable"></div>
    </div>
    <div id="action-queue-container">
        <div id="action-queue-table"></div>
        <div id="action-queue-footer" style="display: flex; justify-content: space-between; align-items: center; padding: 5px; border-top: 1px solid #ccc;">
            <div id="action-queue-summary">
                <span>Items: 0</span> | <span>Total Size: 0 Bytes</span>
            </div>
            <div>
                <button id="reset-button">Reset</button>
                <button id="process-button">Process</button>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    Split(['#duplicatesTable-container', '#action-queue-container'], {
        gutterSize: 10,
        sizes: [70, 30], // Initial sizes in percentage
        minSize: [200, 100], // Minimum sizes in pixels
    });

    let socket;
    let table;
    let actionQueueTable;

    // Global shared data array for reactivity
    let duplicateFilesData = [];

    function getQueueData() {
        return duplicateFilesData.filter(file => file.action !== null);
    }

    actionQueueTable = new Tabulator("#action-queue-table", {
        height: "100%",
        reactiveData: true,
        data: getQueueData(), // Initial data from computed view
        placeholder: "No actions queued",
        layout: "fitColumns",
        columns: [
            {
                title: '<i class="fa fa-trash" title="Clear All Actions"></i>',
                field: "action",
                width: 40,
                headerHozAlign: 'center',
                hozAlign: 'center',
                headerClick: function() {
                    // Clear all actions in the main data source
                    duplicateFilesData.forEach(file => {
                        if (file.action) { // Only update if there's an action to clear
                           file.action = null;
                        }
                    });
                    // The mutator on the main table will handle backend sync
                },
                formatter: function(cell) {
                    const action = cell.getValue();
                    const icon = action === 'delete' ? 'fa-trash' : 'fa-link';
                    return `<i class="fa ${icon}" title="Remove this action"></i>`;
                },
                cellClick: function(e, cell) {
                    const rowData = cell.getRow().getData();
                    // Find the corresponding file in the main data array and clear its action
                    const mainFile = duplicateFilesData.find(f => f.ino === rowData.ino);
                    if (mainFile) {
                        mainFile.action = null; // This will trigger reactivity
                    }
                },
            },
            { title: "File", field: "path", tooltip: true, formatter: "html" }
        ]
    });

    // --- Utility Functions (formerly in helpers.js) ---
    function formatBytes(bytes, decimals = 2) {
        if (!bytes || bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function formatDate(cell) {
        const value = cell.getValue();
        return value ? new Date(value).toLocaleString() : '';
    }

    function formatSize(cell) {
        const value = cell.getValue();
        return formatBytes(value);
    }

    function getReactiveColumnDefinitions() {
        return [
            {
                title: "",
                field: "isOriginal",
                hozAlign: "center",
                headerSort: false,
                width: 30,
                formatter: "tickCross", // Built-in formatter!
                cellClick: function(e, cell) {
                    const row = cell.getRow();
                    const data = row.getData();

                    if (data.isOriginal) return; // Already original, ignore

                    // Find all files in same group and update in the main data array
                    const groupFiles = duplicateFilesData.filter(f => f.groupHash === data.groupHash);
                    groupFiles.forEach(file => {
                        const isNowOriginal = file.ino === data.ino;
                        if (file.isOriginal !== isNowOriginal) {
                           file.isOriginal = isNowOriginal;
                           if (isNowOriginal) {
                               file.action = null; // Clear action for new original
                           }
                        }
                    });

                    // Backend sync
                    dirtySock('setOriginalFile', { hash: data.groupHash, ino: data.ino });

                    // No manual UI update needed - reactivity handles it!
                },
            },
            {
                title: "Action",
                field: "action",
                hozAlign: "center",
                headerSort: false,
                width: 65,
                formatter: function(cell) {
                    const action = cell.getValue();
                    const isOriginal = cell.getRow().getData().isOriginal;
                    if (isOriginal) return ''; // No actions for original files

                    const deleteClass = action === 'delete' ? 'active' : '';
                    const linkClass = action === 'link' ? 'active' : '';
                    return `
                        <div class="action-icons">
                            <i class="fa fa-trash ${deleteClass}" data-action="delete" title="Delete"></i>
                            <i class="fa fa-link ${linkClass}" data-action="link" title="Hardlink"></i>
                        </div>
                    `;
                },
                cellClick: function(e, cell) {
                    if (e.target.tagName !== 'I') return;

                    const row = cell.getRow();
                    if (row.getData().isOriginal) return;

                    const clickedAction = e.target.dataset.action;
                    const currentAction = cell.getValue();

                    // Toggle: if same action clicked, deselect
                    const newAction = currentAction === clickedAction ? null : clickedAction;

                    // Single line update triggers entire reactive chain!
                    row.update({ action: newAction });
                },
                mutator: function(value, data, type, params, component) {
                    // This mutator runs AFTER the data has been changed in the table.
                    // We use it to synchronize the backend.

                    // Validate
                    if (value !== null && !['delete', 'link'].includes(value)) {
                        return null;
                    }

                    // Auto-sync to backend on data edit
                    // The 'type' check ensures this only runs on user edits, not initial load.
                    if (type === "edit" && data.ino) {
                        if (value === null) {
                            dirtySock('removeFileAction', { ino: data.ino, path: data.path.split('<br>')[0] });
                        } else {
                            dirtySock('setFileAction', {
                                ino: data.ino,
                                path: data.path.split('<br>')[0], // Send the first path for simplicity
                                action: value
                            });
                        }
                    }

                    return value;
                }
            },
            {
                title: "File",
                field: "path",
                headerSort: false,
                widthGrow: 1,
                formatter: "html", // Render the <br> tags correctly
                bottomCalc: "count",
            },
            { title: "Size", field: "size", formatter: formatSize, width: 90, resizable: false },
            { title: "Modified", field: "mtime", formatter: formatDate, width: 170, resizable: false },
            { title: "Changed", field: "ctime", formatter: formatDate, width: 170, resizable: false }
        ];
    }

    function createGroupHeader() {
        return function(value, count, data, group) {
            const totalSize = data.reduce((acc, row) => acc + row.size, 0);
            const groupHash = value;

            return `
                <div class="group-header-flex-container">
                    <div class="group-header-main-content">
                        <strong>Group:</strong> ${groupHash}
                        <span class="group-stats">(${count} files, ${formatBytes(totalSize)})</span>
                    </div>
                    <div class="group-action-container">
                        <i class="fa fa-trash" data-action="delete" title="Mark all non-originals for deletion"></i>
                        <i class="fa fa-link" data-action="link" title="Mark all non-originals for hardlinking"></i>
                    </div>
                </div>
            `;
        };
    }

    table = new Tabulator("#duplicatesTable", {
        height: "100%",
        reactiveData: true, // ENABLE REACTIVITY!
        data: duplicateFilesData, // Reference to shared array
        placeholder: "No duplicate files found",
        layout: "fitColumns",
        groupBy: "groupHash",
        groupHeader: createGroupHeader(),
        rowFormatter: function(row) {
            // reactively style the row based on its data
            if (row.getData().isOriginal) {
                row.getElement().classList.add("disabled-row");
            } else {
                row.getElement().classList.remove("disabled-row");
            }
        },
        columns: getReactiveColumnDefinitions()
    });

    // Use Tabulator's built-in group event system for group-level actions
    table.on("groupClick", function(e, group) {
        if (e.target.tagName !== 'I') return;

        const action = e.target.dataset.action;
        const groupHash = group.getKey();
        const groupFiles = duplicateFilesData.filter(f => f.groupHash === groupHash && !f.isOriginal);

        if (groupFiles.length === 0) return;

        // Toggle logic: if all non-original files already have this action, clear it from them.
        // Otherwise, set this action for all of them.
        const allHaveAction = groupFiles.every(f => f.action === action);

        groupFiles.forEach(file => {
            file.action = allHaveAction ? null : action;
        });
        // Reactivity will automatically update the UI and trigger the mutator for backend sync.
    });

    function updateQueueFooter() {
        const queueItems = getQueueData(); // Use the same computed view
        const totalSize = queueItems.reduce((sum, f) => sum + f.size, 0);

        document.getElementById('action-queue-summary').innerHTML =
            `Items: ${queueItems.length} |
Total Size: ${formatBytes(totalSize)}`;
    }

    // Key: Subscribe to main table changes to update queue and footer
    table.on("dataChanged", function() {
        actionQueueTable.setData(getQueueData());
        updateQueueFooter();
    });

    function connect() {
        socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tabulator.page`);

        socket.onopen = function() {
            console.log("Tabulator Tab: WebSocket connection established.");
            dirtySock('findDuplicates', null);
        };

        socket.onmessage = function(event) {
            const { action, data } = JSON.parse(event.data);

            if (action === 'duplicateFiles') {
                // Simple array replacement - reactivity handles UI update
                duplicateFilesData.splice(0, duplicateFilesData.length, ...data);
                console.log('Data updated, UI automatically refreshed');
            } else if (action === 'resetComplete' || action === 'queueCleared') {
                // For now, just re-fetch the data. The reactive UI will update automatically.
                console.log(`Tabulator Tab: Received ${action}. Fetching fresh data.`);
                dirtySock('findDuplicates', null);
            }
        };

        socket.onclose = function(event) {
            console.log("Tabulator Tab: WebSocket connection closed. Reconnecting...");
            setTimeout(connect, 1000);
        };

        socket.onerror = function(error) {
            console.error("Tabulator Tab: WebSocket error: ", error);
            socket.close();
        };
    }

    function dirtySock(action, data) {
        const message = {
            clientId: "dirt-tabulator.page",
            action: action,
            data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(message));
        } else {
            console.error("Tabulator Tab: WebSocket is not connected.");
        }
    }

    connect();

    document.getElementById('reset-button').addEventListener('click', function() {
        if (confirm("Are you sure you want to reset all actions and original file selections?")) {
            // Send message to backend to clear the state. The `resetComplete`
            // message handler will then trigger the data refresh.
            dirtySock('resetState', {});
        }
    });

    document.getElementById('process-button').addEventListener('click', function() {
        const rows = actionQueueTable.getRows();
        if (rows.length === 0) {
            alert("The action queue is empty.");
            return;
        }

        let confirmationMessage = "Are you sure you want to perform the following actions?\n\n";
        rows.forEach(row => {
            const data = row.getData();
            const action = data.action.charAt(0).toUpperCase() + data.action.slice(1); // Capitalize
            confirmationMessage += `${action}: ${data.file}\n`;
        });

        confirm(confirmationMessage);
    });
});
</script>
