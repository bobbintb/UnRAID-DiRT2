Menu="dirtSettings:2"
Title="Tabulator"
---
<link href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator.min.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>

<style>
    .disabled-row {
        background-color: #f2f2f2 !important;
        color: #999 !important;
        pointer-events: none;
    }
    .disabled-row .tabulator-cell {
        pointer-events: none;
    }
</style>
<div id="duplicatesTable"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    let socket;
    let table;

    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    // Helper function to format dates
    function formatDate(cell) {
        const value = cell.getValue();
        return value ? new Date(value).toLocaleString() : '';
    }

    // Helper function to format size
    function formatSize(cell) {
        const row = cell.getRow();
        const data = row.getData();
        const isParent = !!data._children;

        if (isParent) {
            return ""; // Return a blank string for parent rows
        }

        const value = cell.getValue();
        return formatBytes(value);
    }

    // Custom formatter for the tree's first column
    const treeFormatter = (cell, formatterParams, onRendered) => {
        const data = cell.getRow().getData();
        const isParent = !!data._children; // Check if it's a parent group

        if (isParent) {
            const strong = document.createElement('strong');
            strong.textContent = `Group: ${data.hash}`;

            const span = document.createElement('span');
            span.textContent = ` (${data.count} files, ${formatBytes(data.totalSize)})`;

            const container = document.createElement('div');
            container.appendChild(strong);
            container.appendChild(span);
            return container;
        } else {
            // It's a child row, just show the path
            return data.path;
        }
    };

    // The Tabulator table definition
    table = new Tabulator("#duplicatesTable", {
        data: [], // Set initial data to empty
        placeholder: "No duplicate files found",
        dataTree: true,
        dataTreeStartExpanded: true, // Expand all nodes by default
        dataTreeChildIndent: 0, // Remove tree branch indentation
        dataTreeSelectPropagate: false, // Disable default parent/child selection propagation
        rowFormatter: function(row) {
            if (row.getData().isFirstChild) {
                row.getElement().classList.add('disabled-row');
            }
        },
        columns: [
            {
                title: "",
                field: "isPrimary",
                hozAlign: "center",
                headerSort: false,
                width: 40,
                formatter: function(cell, formatterParams, onRendered) {
                    const data = cell.getRow().getData();
                    const isParent = !!data._children;
                    if (isParent) {
                        return "";
                    }
                    const radio = document.createElement("input");
                    radio.type = "radio";
                    radio.name = "primary_group_" + cell.getRow().getTreeParent().getData().hash;
                    radio.checked = data.isFirstChild;
                    return radio;
                },
                cellClick: function(e, cell) {
                    const clickedRow = cell.getRow();
                    const groupRows = clickedRow.getTreeParent().getTreeChildren();

                    groupRows.forEach(row => {
                        const rowEl = row.getElement();
                        if (row === clickedRow) {
                            rowEl.classList.add('disabled-row');
                            row.deselect(); // Clear the checkbox
                        } else {
                            rowEl.classList.remove('disabled-row');
                        }
                    });
                }
            },
            {
                formatter: "rowSelection",
                titleFormatter: "rowSelection",
                hozAlign: "center",
                headerSort: false,
                widthFitData: true,
                resizable: false,
                selectableCheck: function(row) {
                    // Disable checkbox if the row is marked as primary
                    return !row.getElement().classList.contains('disabled-row');
                },
            },
            { title: "File/Group", field: "path", formatter: treeFormatter, headerSort: false, htmlOutput:true, widthGrow: 1 },
            { title: "Size", field: "size", formatter: formatSize, widthFitData: true, resizable: false },
            { title: "Accessed", field: "atime", formatter: formatDate, widthFitData: true, resizable: false },
            { title: "Modified", field: "mtime", formatter: formatDate, widthFitData: true, resizable: false },
            { title: "Changed", field: "ctime", formatter: formatDate, widthFitData: true, resizable: false },
        ],
    });

    let programmaticChange = false;

    table.on("rowSelectionChanged", function(data, rows) {
        if (programmaticChange) {
            return;
        }

        programmaticChange = true;

        // Handle parent-to-child propagation for changed rows
        rows.forEach(function(row) {
            if (row.getTreeChildren().length > 0) { // It's a parent
                const isSelected = row.isSelected();
                row.getTreeChildren().forEach(function(child) {
                    // Only propagate to selectable (not disabled) children
                    if (!child.getElement().classList.contains('disabled-row')) {
                        if (isSelected) {
                            child.select();
                        } else {
                            child.deselect();
                        }
                    }
                });
            }
        });

        // Handle child-to-parent propagation for parents of changed rows
        const parents = new Set();
        rows.forEach(function(row) {
            const parent = row.getTreeParent();
            if (parent) {
                parents.add(parent);
            }
        });

        parents.forEach(function(parent) {
            const selectableChildren = parent.getTreeChildren().filter(child => !child.getElement().classList.contains('disabled-row'));
            const allSelected = selectableChildren.length > 0 && selectableChildren.every(child => child.isSelected());

            if (allSelected) {
                if (!parent.isSelected()) {
                    parent.select();
                }
            } else {
                if (parent.isSelected()) {
                    parent.deselect();
                }
            }
        });

        programmaticChange = false;
    });

    function connect() {
        socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tabulator.page`);

        socket.onopen = function() {
            console.log("Tabulator Tab: WebSocket connection established.");
            dirtySock('findDuplicates', null);
        };

        socket.onmessage = function(event) {
            const parsedMessage = JSON.parse(event.data);
            const { action, data } = parsedMessage;

            if (action === 'duplicateFiles') {
                console.log("Tabulator Tab: Received duplicateFiles data.");
                const tableData = data.map(group => {
                    const children = group.files.map((file, index) => ({
                        ...file,
                        isFirstChild: index === 0, // Flag the first child
                    }));
                    return { ...group, _children: children };
                });
                table.setData(tableData);
            }
        };

        socket.onclose = function(event) {
            console.log("Tabulator Tab: WebSocket connection closed. Reconnecting...");
            setTimeout(connect, 1000);
        };

        socket.onerror = function(error) {
            console.error("Tabulator Tab: WebSocket error: ", error);
            socket.close();
        };
    }

    function dirtySock(action, data) {
        const message = {
            clientId: "dirt-tabulator.page",
            action: action,
            data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(message));
        } else {
            console.error("Tabulator Tab: WebSocket is not connected.");
        }
    }

    connect();
});
</script>
