Menu="DiskUtilities"
Title="Deduplication in Real-Time"
Icon="fa-search-minus"
---
<link href="https://unpkg.com/tabulator-tables@6.3.1/dist/css/tabulator.min.css" rel="stylesheet">
<link href="/plugins/bobbintb.system.dirt/nodejs/css/dirt-tabulator.css" rel="stylesheet">
<script type="text/javascript" src="https://unpkg.com/tabulator-tables@6.3.1/dist/js/tabulator.min.js"></script>
<script src="https://unpkg.com/split.js/dist/split.min.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/dirt-tabulator-helpers.js"></script>
<script src="/plugins/bobbintb.system.dirt/nodejs/dirt-tabulator-formatters.js"></script>
<div id="split">
    <div id="duplicatesTable-container">
        <div id="duplicatesTable"></div>
    </div>
    <div id="action-queue-container">
        <div id="action-queue-table"></div>
        <div id="action-queue-footer" style="display: flex; justify-content: space-between; align-items: center; padding: 5px; border-top: 1px solid #ccc;">
            <div id="action-queue-summary">
                <span>Items: 0</span> | <span>Total Size: 0 Bytes</span>
            </div>
            <div>
                <button id="reset-button">Reset</button>
                <button id="process-button">Process</button>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    Split(['#duplicatesTable-container', '#action-queue-container'], {
        gutterSize: 10,
        sizes: [70, 30], // Initial sizes in percentage
        minSize: [200, 100], // Minimum sizes in pixels
    });

    let socket;
    let table;
    let actionQueueTable;
    let actionQueueData = {}; // To hold the initial queue state

    // The Tabulator table definition for the Action Queue
    actionQueueTable = new Tabulator("#action-queue-table", {
        height: "100%",
        data: [],
        placeholder: "No actions queued",
        layout: "fitColumns",
        columns: [
            {
                title: `<i class="fa fa-trash" style="cursor: pointer;" title="Remove All"></i>`,
                field: "action",
                hozAlign: "center",
                width: 40,
                minWidth: 40,
                resizable: false,
                headerSort: false,
                headerHozAlign: "center",
                headerClick: function(e, column) {
                    const rows = actionQueueTable.getRows();
                    rows.forEach(row => {
                        const cell = row.getCell('action');
                        const icon = cell.getElement().querySelector('i');
                        if (icon) {
                            icon.click();
                        }
                    });
                },
                formatter: createActionQueueActionFormatter(),
                cellClick: function(e, cell) {
                    const rowData = cell.getRow().getData();
                    const filePath = rowData.file;
                    const matchingRows = table.searchRows("path", "=", filePath);
                    if (matchingRows.length > 0) {
                        const mainTableRowData = matchingRows[0].getData();
                        const ino = mainTableRowData.ino;
                        removeFileActionFromQueue(ino, filePath, dirtySock, actionQueueTable, table, updateQueueFooter);
                        const actionCell = matchingRows[0].getCell('action');
                        const radioInputs = actionCell.getElement().querySelectorAll('input[type="radio"]');
                        radioInputs.forEach(radio => {
                            if (radio.checked) {
                                radio.click();
                            }
                        });
                    }
                }
            },
            { title: "File", field: "file", hozAlign: "left", tooltip: true },
        ],
    });

    function getDuplicatesTableColumnDefinitions(actionQueueData, removeFileActionFromQueue, dirtySock, actionQueueTable, mainTable, updateQueueFooter) {
        return [
            {
                title: "",
                field: "isPrimary",
                hozAlign: "center",
                headerSort: false,
                width: 30,
                minWidth: 30,
                resizable: false,
                formatter: createIsPrimaryFormatter(removeFileActionFromQueue, dirtySock, actionQueueTable, mainTable, updateQueueFooter),
            },
            {
                field: "action",
                hozAlign: "center",
                headerSort: false,
                width: 65,
                resizable: false,
                titleFormatter: createActionTitleFormatter(),
                headerClick: function(e, column) {
                    const target = e.target;
                    if (target.tagName !== 'INPUT') return;

                    const action = target.value;
                    const headerEl = column.getElement();
                    const delRadio = headerEl.querySelector('input[value="delete"]');
                    const linkRadio = headerEl.querySelector('input[value="link"]');

                    if (target.checked && target.getAttribute('data-waschecked') === 'true') {
                        target.checked = false;
                        target.setAttribute('data-waschecked', 'false');
                    } else {
                        delRadio.setAttribute('data-waschecked', 'false');
                        linkRadio.setAttribute('data-waschecked', 'false');
                        target.setAttribute('data-waschecked', 'true');
                    }

                    const effectiveCheckedState = target.checked;
                    const groups = table.getGroups();

                    groups.forEach(group => {
                        const groupEl = group.getElement();
                        const groupRadio = groupEl.querySelector(`input[value="${action}"]`);
                        if (groupRadio) {
                            if ((effectiveCheckedState && !groupRadio.checked) || (!effectiveCheckedState && groupRadio.checked)) {
                                groupRadio.click();
                            }
                        }
                    });
                },
                formatter: createActionFormatter(actionQueueData, removeFileActionFromQueue, dirtySock, actionQueueTable, mainTable, updateQueueFooter),
            },
            {
                title: "File",
                field: "path",
                headerSort: false,
                widthGrow: 1,
                bottomCalc: "count",
            },
            { title: "Size", field: "size", formatter: formatSize, width: 90, resizable: false },
            { title: "Modified", field: "mtime", formatter: formatDate, width: 170, resizable: false },
            { title: "Changed", field: "ctime", formatter: formatDate, width: 170, resizable: false }
        ]
    }

    // The Tabulator table definition
    table = new Tabulator("#duplicatesTable", {
        height: "100%",
        data: [],
        placeholder: "No duplicate files found",
        layout: "fitColumns",
        groupBy: "hash",
        groupHeader: createGroupHeader(),
        rowFormatter: createRowFormatter(),
        columns: [], // Columns are set dynamically when data is received
    });

    function connect() {
        socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-tabulator.page`);

        socket.onopen = function() {
            console.log("Tabulator Tab: WebSocket connection established.");
            dirtySock('findDuplicates', null);
        };

        socket.onmessage = function(event) {
            const parsedMessage = JSON.parse(event.data);
            const { action, data } = parsedMessage;

            if (action === 'duplicateFiles') {
                console.log("Tabulator Tab: Received duplicateFiles data package.");
                const { duplicates, state, queue } = data;
                processAndRenderTable(duplicates, state, queue);
            }
        };

        function updateQueueFooter(actionQueueTable, mainTable) {
            const rows = actionQueueTable.getRows();
            const itemCount = rows.length;
            let totalSize = 0;
            rows.forEach(row => {
                const rowData = row.getData();
                const mainTableRow = mainTable.searchRows("path", "=", rowData.file)[0];
                if (mainTableRow) {
                    totalSize += mainTableRow.getData().size;
                }
            });

            const summaryEl = document.getElementById('action-queue-summary');
            summaryEl.innerHTML = `<span>Items: ${itemCount}</span> | <span>Total Size: ${formatBytes(totalSize)}</span>`;
        }

        function processAndRenderTable(duplicateFilesData, originalFileState, receivedActionQueueData) {
            console.log("Tabulator Tab: Processing and rendering tables.");
            actionQueueData = receivedActionQueueData;
            const queueTableData = Object.entries(receivedActionQueueData).map(([path, action]) => ({
                action: action,
                file: path,
            }));
            actionQueueTable.setData(queueTableData);

            const tableData = [];
            duplicateFilesData.forEach(group => {
                const originalIno = originalFileState[group.hash];
                group.files.forEach((file, index) => {
                    const isOriginal = originalIno ? (file.ino === originalIno) : (index === 0);
                    tableData.push({
                        ...file,
                        hash: group.hash,
                        isOriginal: isOriginal
                    });
                });
            });
            const newColumns = getDuplicatesTableColumnDefinitions(actionQueueData, removeFileActionFromQueue, dirtySock, actionQueueTable, table, updateQueueFooter);
            table.setColumns(newColumns);
            table.setData(tableData).then(() => {
                updateQueueFooter(actionQueueTable, table);
            });
        }

        socket.onclose = function(event) {
            console.log("Tabulator Tab: WebSocket connection closed. Reconnecting...");
            setTimeout(connect, 1000);
        };

        socket.onerror = function(error) {
            console.error("Tabulator Tab: WebSocket error: ", error);
            socket.close();
        };
    }

    function dirtySock(action, data) {
        const message = {
            clientId: "dirt-tabulator.page",
            action: action,
            data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(message));
        } else {
            console.error("Tabulator Tab: WebSocket is not connected.");
        }
    }

    connect();

    document.getElementById('reset-button').addEventListener('click', function() {
        if (confirm("Are you sure you want to reset all actions and original file selections?")) {
            // Send message to backend to clear state
            dirtySock('resetState', {});

            // Clear the action queue table in the UI
            actionQueueTable.clearData();
            // Mutate the actionQueueData object to clear it, ensuring all references see the change
            for (const key in actionQueueData) {
                delete actionQueueData[key];
            }
            updateQueueFooter(actionQueueTable, table);

            // Get all data from the table
            const tableData = table.getData();

            // Group data by hash to reset the isOriginal flag
            const groupedData = tableData.reduce((acc, row) => {
                acc[row.hash] = acc[row.hash] || [];
                acc[row.hash].push(row);
                return acc;
            }, {});

            Object.values(groupedData).forEach(group => {
                group.forEach((row, index) => {
                    row.isOriginal = (index === 0);
                });
            });

            // Set the updated data back to the table to ensure the data model is correct.
            table.setData(tableData).then(() => {
                // Force a full redraw of the table to ensure all formatters are re-run
                // with the cleared actionQueueData state. This is the definitive fix.
                table.redraw(true);
            });
        }
    });

    document.getElementById('process-button').addEventListener('click', function() {
        const rows = actionQueueTable.getRows();
        if (rows.length === 0) {
            alert("The action queue is empty.");
            return;
        }

        let confirmationMessage = "Are you sure you want to perform the following actions?\n\n";
        rows.forEach(row => {
            const data = row.getData();
            const action = data.action.charAt(0).toUpperCase() + data.action.slice(1); // Capitalize
            confirmationMessage += `${action}: ${data.file}\n`;
        });

        confirm(confirmationMessage);
    });
});
</script>
