Menu="DiskUtilities"
Title="Deduplication in Real-Time (DataTables)"
Icon="fa-search-minus"
---
<link rel="stylesheet" href="https://cdn.datatables.net/2.3.4/css/dataTables.dataTables.min.css">
<script src="https://cdn.datatables.net/2.3.4/js/dataTables.min.js"></script>
<script src="https://unpkg.com/split.js/dist/split.min.js"></script>

<style>
    /* Basic styling for the split layout */
    .split-container {
        display: flex;
        flex-direction: row;
        height: calc(100vh - 245px); /* Adjust for Unraid header/footer */
        width: 100%;
    }
    .split {
        padding: 10px;
        box-sizing: border-box;
        overflow: auto;
    }
    .gutter {
        background-color: #f7f7f7;
        background-repeat: no-repeat;
        background-position: 50%;
    }
    .gutter.gutter-horizontal {
        cursor: col-resize;
        width: 10px;
    }
    tr.group {
        cursor: pointer;
    }
    .disabled-row {
        pointer-events: none;
        opacity: 0.5;
        background-color: #f2f2f2;
    }
</style>

<div class="split-container">
    <div id="left-pane" class="split">
        <table id="datatables-table" style="width:100%"></table>
    </div>
    <div id="right-pane" class="split">
        <table id="right-table-datatables" style="width:100%"></table>
    </div>
</div>

<script>
$(document).ready(function() {
    Split(['#left-pane', '#right-pane'], {
        sizes: [70, 30],
        minSize: [300, 150],
        gutterSize: 10,
        cursor: 'col-resize',
    });

    // --- WebSocket and Table Implementation ---
    let socket;
    let leftTable;
    let rightTable;

    // Custom filter for the right table: only show rows with a queued action.
    $.fn.dataTable.ext.search.push(function(settings, data, dataIndex, rowData) {
        if (settings.nTable.id !== 'right-table-datatables') {
            return true; // Don't filter other tables
        }
        // For the right-table, only show rows where queuedAction is not null or undefined.
        return !!rowData.queuedAction;
    });


    function formatBytes(bytes, decimals = 2) {
        if (!bytes || bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function formatDate(timestamp) {
        if (!timestamp) return '';
        return new Date(timestamp).toLocaleString();
    }


    function connect() {
        socket = new WebSocket(`ws://${window.location.hostname}:41820?clientId=dirt-datatables.page`);

        socket.onopen = function() {
            console.log("DataTables Tab: WebSocket connection established.");
            dirtySock('findDuplicates', null);
        };

        socket.onmessage = function(event) {
            const parsedMessage = JSON.parse(event.data);
            const { action, data } = parsedMessage;

            if (action === 'duplicateFiles') {
                console.log("DataTables Tab: Received duplicateFiles data package.");
                const { duplicates, state, queue } = data;

                const flatData = duplicates.flatMap(group => {
                    const originalFileInode = state ? state[group.hash] : null;

                    return group.files.map((file, index) => {
                        let isOriginal = false;
                        if (originalFileInode) {
                            isOriginal = file.ino.toString() === originalFileInode.toString();
                        } else if (index === 0) {
                            isOriginal = true;
                        }

                        const queuedAction = queue ? queue[file.path] : null;

                        return {
                            ...file,
                            hash: group.hash,
                            isOriginal: isOriginal,
                            queuedAction: queuedAction,
                        };
                    });
                });

                initializeTables(flatData);
            }
        };

        socket.onclose = function(event) {
            console.log("DataTables Tab: WebSocket connection closed. Reconnecting...");
            setTimeout(connect, 1000);
        };

        socket.onerror = function(error) {
            console.error("DataTables Tab: WebSocket error: ", error);
            socket.close();
        };
    }

    function initializeTables(data) {
        // Left Table
        if ($.fn.DataTable.isDataTable('#datatables-table')) {
            $('#datatables-table').DataTable().destroy();
            $('#datatables-table tbody').empty();
        }

        leftTable = new DataTable('#datatables-table', {
            data: data,
            paging: false,
            searching: false,
            info: false,
            autoWidth: false,
            language: {
                emptyTable: "No duplicate files found."
            },
            columns: [{
                data: 'hash'
            }, {
                data: 'isOriginal',
                title: '',
                width: '40px',
                orderable: false,
                render: function(data, type, row) {
                    return '<input type="radio" class="original-file-radio" name="' + row.hash + '" value="' + row.ino + '" ' + (data ? 'checked' : '') + '>';
                }
            }, {
                data: null,
                title: '',
                orderable: false,
                render: function(data, type, row) {
                    const isDelete = row.queuedAction === 'delete';
                    const isLink = row.queuedAction === 'link';
                    return `
                        <span class="action-radios">
                            <input type="radio" name="action_${row.path}" value="delete" title="Delete this file" ${isDelete ? 'checked' : ''}>
                            <input type="radio" name="action_${row.path}" value="link" title="Hardlink this file" ${isLink ? 'checked' : ''}>
                        </span>
                    `;
                }
            }, {
                data: 'path',
                title: 'Path'
            }, {
                data: 'size',
                title: 'Size',
                render: (d, t, r) => t === 'display' ? formatBytes(d) : d
            }, {
                data: 'mtime',
                title: 'Modified',
                render: (d, t, r) => t === 'display' ? formatDate(d) : d
            }],
            columnDefs: [{
                visible: false,
                targets: 0
            }],
            order: [
                [0, 'asc']
            ],
            rowCallback: function(row, data, dataIndex) {
                if (data.isOriginal) {
                    $(row).addClass('disabled-row');
                } else {
                    $(row).removeClass('disabled-row');
                }
            },
            drawCallback: function(settings) {
                const api = this.api();
                const rows = api.rows({
                    page: 'current'
                }).nodes();
                let last = null;

                api.column(0, {
                    page: 'current'
                }).data().each(function(group, i) {
                    if (last !== group) {
                        const groupRow = $('<tr class="group" style="background-color: #f0f0f0; font-weight: bold; color: black;"><td colspan="4"><span class="toggle-icon">▼</span> ' + group + '</td></tr>');
                        $(rows).eq(i).before(groupRow);
                        last = group;
                    }
                });
            }
        });

        $('#datatables-table tbody').off('click', 'tr.group').on('click', 'tr.group', function() {
            const $groupRow = $(this);
            const icon = $groupRow.find('.toggle-icon');

            let $rows = $groupRow.nextUntil('tr.group');

            if ($rows.length > 0) {
                $rows.toggle();
                icon.text($rows.first().is(':visible') ? '▼' : '▶');
            }
        });

        $('#datatables-table tbody').on('click', 'input.original-file-radio', function() {
            const table = $('#datatables-table').DataTable();
            const selectedRow = $(this).closest('tr');
            const rowData = table.row(selectedRow).data();

            if (rowData.isOriginal) {
                return;
            }

            // Send WebSocket message to update state
            dirtySock('setOriginalFile', {
                hash: rowData.hash,
                ino: rowData.ino
            });

            // When a file is selected as original, any pending action for it should be cleared.
            dirtySock('removeFileAction', { path: rowData.path });

            // Update the data source to clear the action, which will then be reflected on redraw.
            rowData.queuedAction = null;

            // Update UI for all rows in the same group
            table.rows().every(function() {
                const d = this.data();
                if (d.hash === rowData.hash) {
                    const isOriginal = d.ino === rowData.ino;
                    if (d.isOriginal !== isOriginal) {
                        d.isOriginal = isOriginal;
                        this.invalidate();
                    }
                }
            });

            table.draw(false);
            rightTable.draw(false); // Redraw the right table to reflect the cleared action
        });

        $('#datatables-table tbody').on('mousedown', '.action-radios input[type="radio"]', function(e) {
            if (this.checked) {
                this.isDeselecting = true;
            }
        });

        $('#datatables-table tbody').on('click', '.action-radios input[type="radio"]', function(e) {
            const table = $('#datatables-table').DataTable();
            const selectedRow = $(this).closest('tr');
            const rowData = table.row(selectedRow).data();

            if (this.isDeselecting) {
                this.checked = false;
                this.isDeselecting = false;
                rowData.queuedAction = null; // Update the data source
                dirtySock('removeFileAction', { path: rowData.path });
            } else {
                rowData.queuedAction = this.value; // Update the data source
                dirtySock('setFileAction', { path: rowData.path, action: this.value });
            }

            // Redraw both tables to reflect the change
            leftTable.draw(false);
            rightTable.draw(false);
        });

        // Right Table
        if ($.fn.DataTable.isDataTable('#right-table-datatables')) {
            $('#right-table-datatables').DataTable().destroy();
        }

        rightTable = new DataTable('#right-table-datatables', {
            data: data, // Use the same shared data source
            paging: false,
            searching: false,
            info: false,
            autoWidth: false,
            language: {
                emptyTable: "No actions selected."
            },
            columns: [
                { data: 'queuedAction', title: 'Action', defaultContent: "" },
                { data: 'path', title: 'Path' }
            ]
        });
    }

    function dirtySock(action, data) {
        const message = {
            clientId: "dirt-datatables.page",
            action: action,
            data: data
        };
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify(message));
        } else {
            console.error("DataTables Tab: WebSocket is not connected.");
        }
    }

    // Initial setup on DOM ready
    initializeTables([]);
    connect();
});
</script>
